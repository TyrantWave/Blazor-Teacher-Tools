// <auto-generated />
//
// To parse this JSON data, add NuGet 'Newtonsoft.Json' then do:
//
//    using TeacherTools.Services;
//
//    var wordInfo = WordInfo.FromJson(jsonString);

namespace TeacherTools.Services
{
	using System;
	using System.Collections.Generic;

	using System.Globalization;
	using Newtonsoft.Json;
	using Newtonsoft.Json.Converters;

	public partial class WordInfo
	{
		[JsonProperty("word", NullValueHandling = NullValueHandling.Ignore)]
		public string Word { get; set; }

		[JsonProperty("results", NullValueHandling = NullValueHandling.Ignore)]
		public List<Result> Results { get; set; }

		[JsonProperty("syllables", NullValueHandling = NullValueHandling.Ignore)]
		public Syllables Syllables { get; set; }

		[JsonProperty("pronunciation", NullValueHandling = NullValueHandling.Ignore)]
        [JsonConverter(typeof(PronunciationConverter))]
		public Pronunciation Pronunciation { get; set; }

		[JsonProperty("frequency", NullValueHandling = NullValueHandling.Ignore)]
		public double? Frequency { get; set; }
	}

	public partial class Pronunciation
	{
		[JsonProperty("all", NullValueHandling = NullValueHandling.Ignore)]
		public string All { get; set; }

		[JsonProperty("noun", NullValueHandling = NullValueHandling.Ignore)]
		public string Noun { get; set; }

		[JsonProperty("verb", NullValueHandling = NullValueHandling.Ignore)]
		public string Verb { get; set; }
	}

	public partial class Result
	{
		[JsonProperty("definition", NullValueHandling = NullValueHandling.Ignore)]
		public string Definition { get; set; }

		[JsonProperty("partOfSpeech", NullValueHandling = NullValueHandling.Ignore)]
		public string PartOfSpeech { get; set; }

		[JsonProperty("synonyms", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> Synonyms { get; set; }

		[JsonProperty("antonyms", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> Antonyms { get; set; }

		[JsonProperty("typeOf", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> TypeOf { get; set; }

		[JsonProperty("hasTypes", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> HasTypes { get; set; }

		[JsonProperty("derivation", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> Derivation { get; set; }

		[JsonProperty("examples", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> Examples { get; set; }

		[JsonProperty("inCategory", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> InCategory { get; set; }

		[JsonProperty("cause", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> Cause { get; set; }
	}

	public partial class Syllables
	{
		[JsonProperty("count", NullValueHandling = NullValueHandling.Ignore)]
		public long? Count { get; set; }

		[JsonProperty("list", NullValueHandling = NullValueHandling.Ignore)]
		public List<string> List { get; set; }
	}

	public partial class WordInfo
	{
		public static WordInfo FromJson(string json) => JsonConvert.DeserializeObject<WordInfo>(json, TeacherTools.Services.Converter.Settings);
	}

	public static class Serialize
	{
		public static string ToJson(this WordInfo self) => JsonConvert.SerializeObject(self, TeacherTools.Services.Converter.Settings);
	}

	public class PronunciationConverter : JsonConverter
	{
		public override bool CanConvert(Type objecttype)
		{
            return objecttype == typeof(Pronunciation);
		}

		public override bool CanWrite
		{
			get { return false; }
		}

        public override object ReadJson(JsonReader reader, Type objecttype, object value, JsonSerializer serializer)
        {
            if (reader.TokenType == JsonToken.Null) return null;

            // Sometimes just a string is returned for the phonetic guide, so populate a basic Pronunciation type
            if (reader.TokenType == JsonToken.String)
            {
                return new Pronunciation
                {
                    All = (string)reader.Value,
                    Noun = null,
                    Verb = null
                };
            }

            var resp = new Pronunciation();
            serializer.Populate(reader, resp);
            return resp;
        }

		public override void WriteJson(JsonWriter writer, object value, JsonSerializer serializer)
		{
			throw new NotImplementedException();
		}
	}

	internal static class Converter
	{
		public static readonly JsonSerializerSettings Settings = new JsonSerializerSettings
		{
			MetadataPropertyHandling = MetadataPropertyHandling.Ignore,
			DateParseHandling = DateParseHandling.None,
            Converters =
			{
				new IsoDateTimeConverter { DateTimeStyles = DateTimeStyles.AssumeUniversal },
				new PronunciationConverter(),
			},
		};
	}
}
